<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
    />
    <title>Map</title>
    <link rel="stylesheet" href="leaflet/leaflet.css" />
    <link
            rel="stylesheet"
            href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
            integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
            crossorigin=""
    />
    <style>
        html,
        body,
        #map {
          height: 100%;
          margin: 0;
        }
        #status {
          position: absolute;
          left: 12px;
          bottom: 12px;
          background: rgba(0, 0, 0, 0.65);
          color: #fff;
          padding: 6px 10px;
          border-radius: 6px;
          font-size: 12px;
          z-index: 1000;
        }
                #tile-toggle {
          position: absolute;
          right: 12px;
          top: 12px;
          background: rgba(0, 0, 0, 0.65);
          color: #fff;
          padding: 6px 10px;
          border-radius: 6px;
          font-size: 12px;
          z-index: 1000;
          display: flex;
          align-items: center;
          gap: 6px;
        }
        #tile-toggle input {
          margin: 0;
        }
        .footprint-marker {
          font-size: 16px;
          line-height: 1;
          color: #f08c00;
          text-shadow: 0 0 2px rgba(0, 0, 0, 0.35);
          transform: translate(-50%, -50%);
          pointer-events: none;
        }
        .footprint-glyph {
          display: inline-block;
          transform-origin: center center;
        }
    </style>
</head>
<body>
<div id="map"></div>
<div id="status">TIF: Á≠âÂæÖÂä†ËΩΩ...</div>
<label id="tile-toggle">
    <input id="tile-toggle-input" type="checkbox" checked />
    Edinburgh in 1844
</label>
<button id="tile-fit" type="button">ÂÆö‰ΩçÁì¶Áâá</button>
<script>
    let map = null;
    let userMarker = null;
    let hasCentered = false;
    let userIcon = null;
    let trackPoints = [];
    let trackFootprints = null;
    let footprintRemainderMeters = 0;
    const FOOTPRINT_STEP_METERS = 4;
    let rasterLayer = null;
    const storyAreas = {};

    const GEO_CONFIG = {
      tileSize: 256,
      localTileEnabled: true,
      localTileUrl: "https://appassets.androidplatform.net/assets/tiles/{z}/{x}/{y}.png",
      localTileCrs: "EPSG:3395",
      localTileCrsDef: "+proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs",
      localTileBounds: [-20037508.3427892, -20037508.3427892, 20037508.3427892, 20037508.3427892],
    };
    function updateLocation(lat, lon) {
      if (!map) {
        return;
      }
      const latLng = [lat, lon];
      if (!userMarker) {
        userMarker = L.marker(latLng, { icon: userIcon }).addTo(map);
      } else {
        userMarker.setLatLng(latLng);
      }
      if (!hasCentered) {
        map.setView(latLng, 17);
        hasCentered = true;
      }
    }

    function centerOnUser(zoom) {
      if (!map || !userMarker) {
        return;
      }
      const targetZoom = Number.isFinite(zoom) ? zoom : map.getZoom();
      map.setView(userMarker.getLatLng(), targetZoom);
    }

    function startTrackLine() {
      if (!map) {
        return;
      }
      trackPoints = [];
      footprintRemainderMeters = 0;
      if (!trackFootprints) {
        trackFootprints = L.layerGroup().addTo(map);
      } else {
        trackFootprints.clearLayers();
      }
    }

    function createFootprintIcon(rotationDeg) {
      const safeDeg = Number.isFinite(rotationDeg) ? rotationDeg : 0;
      return L.divIcon({
        className: "footprint-marker",
        html: `<span class="footprint-glyph" style="transform: rotate(${safeDeg.toFixed(1)}deg);">üë£</span>`,
        iconSize: [16, 16],
      });
    }

    function calculateFootprintRotationDeg(prevLatLng, nextLatLng) {
      if (!prevLatLng || !nextLatLng) {
        return 0;
      }
      const dLat = nextLatLng[0] - prevLatLng[0];
      const dLng = nextLatLng[1] - prevLatLng[1];
      if (Math.abs(dLat) < 1e-9 && Math.abs(dLng) < 1e-9) {
        return 0;
      }
      return Math.atan2(dLng, dLat) * (180 / Math.PI);
    }

    function drawFootprintsBetween(prevLatLng, nextLatLng) {
      if (!map || !trackFootprints || !prevLatLng || !nextLatLng) {
        return;
      }
      const p1 = L.latLng(prevLatLng[0], prevLatLng[1]);
      const p2 = L.latLng(nextLatLng[0], nextLatLng[1]);
      const segmentDistance = map.distance(p1, p2);
      if (!Number.isFinite(segmentDistance) || segmentDistance <= 0.5) {
        return;
      }

      const rotationDeg = calculateFootprintRotationDeg(prevLatLng, nextLatLng);
      const footprintIcon = createFootprintIcon(rotationDeg);

      let nextOffset = footprintRemainderMeters > 0
        ? footprintRemainderMeters
        : FOOTPRINT_STEP_METERS;

      while (nextOffset <= segmentDistance) {
        const ratio = nextOffset / segmentDistance;
        const lat = p1.lat + (p2.lat - p1.lat) * ratio;
        const lng = p1.lng + (p2.lng - p1.lng) * ratio;
        L.marker([lat, lng], { icon: footprintIcon, interactive: false }).addTo(trackFootprints);
        nextOffset += FOOTPRINT_STEP_METERS;
      }

      footprintRemainderMeters = nextOffset - segmentDistance;
      if (footprintRemainderMeters >= FOOTPRINT_STEP_METERS) {
        footprintRemainderMeters = footprintRemainderMeters % FOOTPRINT_STEP_METERS;
      }
    }

    function addTrackPoint(lat, lon) {
      if (!map) {
        return;
      }
      const latLng = [lat, lon];
      const prev = trackPoints.length > 0 ? trackPoints[trackPoints.length - 1] : null;
      trackPoints.push(latLng);

      if (trackPoints.length === 1 && trackFootprints) {
        const startIcon = createFootprintIcon(0);
        L.marker(latLng, { icon: startIcon, interactive: false }).addTo(trackFootprints);
        return;
      }

      drawFootprintsBetween(prev, latLng);
    }

    function finishTrackLine() {
      return;
    }

    function isPointInPolygon(point, polygonLatLngs) {
      if (!point || !Array.isArray(polygonLatLngs) || polygonLatLngs.length < 3) {
        return false;
      }
      let inside = false;
      let j = polygonLatLngs.length - 1;
      for (let i = 0; i < polygonLatLngs.length; i += 1) {
        const xi = polygonLatLngs[i][1];
        const yi = polygonLatLngs[i][0];
        const xj = polygonLatLngs[j][1];
        const yj = polygonLatLngs[j][0];
        const intersect = (yi > point.lat) !== (yj > point.lat)
          && point.lng < ((xj - xi) * (point.lat - yi)) / (yj - yi) + xi;
        if (intersect) {
          inside = !inside;
        }
        j = i;
      }
      return inside;
    }

    function renderStoryArea(storyId, latLngs, label) {
      if (!map || !Array.isArray(latLngs) || !storyId) {
        return;
      }
      const polygon = L.polygon(latLngs, {
        color: "#D97A7A",
        weight: 2,
        fillColor: "#F4A6A6",
        fillOpacity: 0.35,
      }).addTo(map);
      storyAreas[storyId] = {
        polygon,
        latLngs,
      };
      if (label) {
        polygon.bindTooltip(label, { direction: "top" });
      }
      polygon.on("click", () => {
        if (!userMarker || !isPointInPolygon(userMarker.getLatLng(), latLngs)) {
          window.alert("Êú™ËøõÂÖ•ÂõûÂøÜËåÉÂõ¥");
          return;
        }
        triggerMemoryFromMap(storyId);
      });
    }

    function triggerMemoryFromMap(storyId) {
      if (!storyId) {
        return;
      }
      if (storyId && window.Android && typeof window.Android.onMemoryClick === "function") {
        window.Android.onMemoryClick(storyId);
      }
    }

    window.triggerMemoryFromMap = triggerMemoryFromMap;

    const statusEl = document.getElementById("status");
    const tileFitButton = document.getElementById("tile-fit");
    const tileToggleInput = document.getElementById("tile-toggle-input");

    function setLocalTilesVisible(visible) {
      if (!map || !rasterLayer) {
        return;
      }
      if (visible) {
        if (!map.hasLayer(rasterLayer)) {
          rasterLayer.addTo(map);
        }
      } else if (map.hasLayer(rasterLayer)) {
        map.removeLayer(rasterLayer);
      }
    }


    function setStatus(text) {
      if (statusEl) {
        statusEl.textContent = text;
      }
    }

        function getLocalTileBounds() {
      if (!map || !GEO_CONFIG.localTileBounds) {
        return null;
      }
      const [minX, minY, maxX, maxY] = GEO_CONFIG.localTileBounds;
      const crs = map.options.crs;
      if (!crs || typeof crs.unproject !== "function") {
        return null;
      }
      const southWest = crs.unproject(L.point(minX, minY));
      const northEast = crs.unproject(L.point(maxX, maxY));
      return L.latLngBounds(southWest, northEast);
    }

    function loadScript(url) {
      return new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = url;
        script.async = true;
        script.onload = () => resolve(url);
        script.onerror = () => reject(new Error(`ËÑöÊú¨Âä†ËΩΩÂ§±Ë¥•: ${url}`));
        document.head.appendChild(script);
      });
    }

    async function loadScriptsSequential(urls) {
      let lastError = null;
      for (const url of urls) {
        try {
          setStatus(`Âä†ËΩΩËÑöÊú¨: ${url}`);
          await loadScript(url);
          return url;
        } catch (error) {
          lastError = error;
        }
      }
      throw lastError || new Error("ËÑöÊú¨Âä†ËΩΩÂ§±Ë¥•");
    }

    function loadLocalTileLayer() {
      if (!map) {
        return;
      }
      const { localTileUrl, tileSize } = GEO_CONFIG;
      if (!localTileUrl) {
        setStatus("Êú¨Âú∞Áì¶Áâá: ÈÖçÁΩÆ‰∏çÂÆåÊï¥");
        return;
      }

      setStatus("Êú¨Âú∞Áì¶Áâá: Âä†ËΩΩ‰∏≠...");
      rasterLayer = L.tileLayer(localTileUrl, {
        tileSize,
        maxZoom: 18,
        tms: false,
      });

      rasterLayer.addTo(map);
      setStatus("Êú¨Âú∞Áì¶Áâá: Â∑≤Âä†ËΩΩ");
    }

    function initMap() {
      map = L.map("map", {
        zoomControl: true,
        attributionControl: true,
      }).setView([39.9042, 116.4074], 15);

      L.tileLayer("https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png", {
        subdomains: ["a", "b", "c"],
        maxZoom: 21,
        attribution:
          '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, HOT',
      }).addTo(map);
    }

    async function loadLeaflet() {
      await loadScriptsSequential([
        "leaflet/leaflet.js",
      ]);
      if (typeof L === "undefined") {
        throw new Error("Leaflet ËÑöÊú¨Êú™Âä†ËΩΩ");
      }
      userIcon = L.icon({
        iconUrl: "https://appassets.androidplatform.net/res/drawable/cursor.png",
        iconSize: [120, 120],
        iconAnchor: [60, 60],
      });
    }

    async function initRasterLayer() {
      try {
        if (GEO_CONFIG.localTileEnabled) {
          loadLocalTileLayer();
          return;
        }
        setStatus("ËÑöÊú¨Âä†ËΩΩÂÆåÊàêÔºåÂáÜÂ§áÂä†ËΩΩÊú¨Âú∞Áì¶Áâá");
        loadLocalTiff();
      } catch (error) {
        console.error(error);
        setStatus(`ËÑöÊú¨Âä†ËΩΩÂ§±Ë¥•: ${error.message || error}`);
      }
    }

    async function init() {
      try {
        await loadLeaflet();
        initMap();
        await initRasterLayer();
        if (tileToggleInput) {
          tileToggleInput.checked = GEO_CONFIG.localTileEnabled;
          tileToggleInput.addEventListener("change", (event) => {
            setLocalTilesVisible(event.target.checked);
          });
        }
      } catch (error) {
        console.error(error);
        setStatus(`Leaflet Âä†ËΩΩÂ§±Ë¥•: ${error.message || error}`);
      }
    }

    init();
</script>
</body>
</html>
