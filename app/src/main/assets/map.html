<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
    />
    <title>Map</title>
    <link rel="stylesheet" href="leaflet/leaflet.css" />
    <link
            rel="stylesheet"
            href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
            integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
            crossorigin=""
    />
    <style>
        html,
        body,
        #map {
          height: 100%;
          margin: 0;
        }
        #status {
          position: absolute;
          left: 12px;
          bottom: 12px;
          background: rgba(0, 0, 0, 0.65);
          color: #fff;
          padding: 6px 10px;
          border-radius: 6px;
          font-size: 12px;
          z-index: 1000;
        }
                #tile-toggle {
          position: absolute;
          right: 12px;
          top: 12px;
          background: rgba(0, 0, 0, 0.65);
          color: #fff;
          padding: 6px 10px;
          border-radius: 6px;
          font-size: 12px;
          z-index: 1000;
          display: flex;
          align-items: center;
          gap: 6px;
        }
        #tile-toggle input {
          margin: 0;
        }
        .footprint-marker {
          font-size: 16px;
          line-height: 1;
          color: #f08c00;
          text-shadow: 0 0 2px rgba(0, 0, 0, 0.35);
          transform: translate(-50%, -50%);
          pointer-events: none;
        }
    </style>
</head>
<body>
<div id="map"></div>
<div id="status">TIF: Á≠âÂæÖÂä†ËΩΩ...</div>
<label id="tile-toggle">
    <input id="tile-toggle-input" type="checkbox" checked />
    Edinburgh in 1844
</label>
<button id="tile-fit" type="button">ÂÆö‰ΩçÁì¶Áâá</button>
<script>
    let map = null;
    let userMarker = null;
    let hasCentered = false;
    let userIcon = null;
    let trackPolyline = null;
    let trackPoints = [];
    let trackFootprints = null;
    let rasterLayer = null;
    const storyAreas = {};
    const storyAreaStates = {};

    const GEO_CONFIG = {
      tileSize: 256,
      localTileEnabled: true,
      localTileUrl: "https://appassets.androidplatform.net/assets/tiles/{z}/{x}/{y}.png",
      localTileCrs: "EPSG:3395",
      localTileCrsDef: "+proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs",
      localTileBounds: [-20037508.3427892, -20037508.3427892, 20037508.3427892, 20037508.3427892],
    };
    function updateLocation(lat, lon) {
      if (!map) {
        return;
      }
      const latLng = [lat, lon];
      if (!userMarker) {
        userMarker = L.marker(latLng, { icon: userIcon }).addTo(map);
      } else {
        userMarker.setLatLng(latLng);
      }
      if (!hasCentered) {
        map.setView(latLng, 17);
        hasCentered = true;
      }
    }

    function centerOnUser(zoom) {
      if (!map || !userMarker) {
        return;
      }
      const targetZoom = Number.isFinite(zoom) ? zoom : map.getZoom();
      map.setView(userMarker.getLatLng(), targetZoom);
    }

    function startTrackLine() {
      if (!map) {
        return;
      }
      trackPoints = [];
      if (trackPolyline) {
        map.removeLayer(trackPolyline);
      }
      trackPolyline = L.polyline(trackPoints, {
        color: "#F08C00",
        weight: 3,
        opacity: 0.35,
        lineJoin: "round",
      }).addTo(map);
      if (!trackFootprints) {
        trackFootprints = L.layerGroup().addTo(map);
      } else {
        trackFootprints.clearLayers();
      }
    }

    function addTrackPoint(lat, lon) {
      if (!map || !trackPolyline) {
        return;
      }
      const latLng = [lat, lon];
      trackPoints.push(latLng);
      trackPolyline.setLatLngs(trackPoints);

      if (trackFootprints) {
        const footprintIcon = L.divIcon({
          className: "footprint-marker",
          html: "üë£",
          iconSize: [16, 16],
        });
        L.marker(latLng, { icon: footprintIcon, interactive: false }).addTo(trackFootprints);
      }
    }

    function finishTrackLine() {
      if (!map || !trackPolyline) {
        return;
      }
      trackPolyline.setLatLngs(trackPoints);
    }

    function renderStoryArea(storyId, latLngs, label) {
      if (!map || !Array.isArray(latLngs) || !storyId) {
        return;
      }
      const polygon = L.polygon(latLngs, {
        color: "#D97A7A",
        weight: 2,
        fillColor: "#F4A6A6",
        fillOpacity: 0.2,
      }).addTo(map);
      storyAreas[storyId] = {
        polygon,
        popup: null,
        center: polygon.getBounds().getCenter(),
      };
      storyAreaStates[storyId] = true;
      if (label) {
        polygon.bindTooltip(label, { direction: "top" });
      }
      polygon.on("click", () => {
        showStoryAreaButton(storyId);
      });
    }

    function showStoryAreaButton(storyId) {
      const area = storyAreas[storyId];
      if (!map || !area) {
        return;
      }
      const escapedStoryId = String(storyId)
        .replace(/\\/g, "\\\\")
        .replace(/'/g, "\\'");
      const buttonHtml = `
        <button
          type="button"
          class="memory-btn"
          data-story-id="${storyId}"
          onclick="triggerMemoryFromMap('${escapedStoryId}')"
        >
          ÂõûÂøÜ
        </button>
      `;
      if (!area.popup) {
        area.popup = L.popup({ closeButton: true, autoPan: true });
      }
      area.popup.setLatLng(area.center).setContent(buttonHtml).openOn(map);
    }

    function setStoryAreaAvailability(storyId, available) {
      if (!storyId || !(storyId in storyAreaStates)) {
        return;
      }
      storyAreaStates[storyId] = Boolean(available);
      const area = storyAreas[storyId];
      if (area && area.popup && map && map.hasLayer(area.popup)) {
        showStoryAreaButton(storyId);
      }
    }

    function triggerMemoryFromMap(storyId) {
      if (!storyId) {
        return;
      }
      if (storyId && window.Android && typeof window.Android.onMemoryClick === "function") {
        window.Android.onMemoryClick(storyId);
      }
    }

    document.addEventListener("click", (event) => {
      const target = event.target;
      if (!target || !target.classList.contains("memory-btn")) {
        return;
      }
      triggerMemoryFromMap(target.getAttribute("data-story-id"));
    });

    window.triggerMemoryFromMap = triggerMemoryFromMap;

    const statusEl = document.getElementById("status");
    const tileFitButton = document.getElementById("tile-fit");
    const tileToggleInput = document.getElementById("tile-toggle-input");

    function setLocalTilesVisible(visible) {
      if (!map || !rasterLayer) {
        return;
      }
      if (visible) {
        if (!map.hasLayer(rasterLayer)) {
          rasterLayer.addTo(map);
        }
      } else if (map.hasLayer(rasterLayer)) {
        map.removeLayer(rasterLayer);
      }
    }


    function setStatus(text) {
      if (statusEl) {
        statusEl.textContent = text;
      }
    }

        function getLocalTileBounds() {
      if (!map || !GEO_CONFIG.localTileBounds) {
        return null;
      }
      const [minX, minY, maxX, maxY] = GEO_CONFIG.localTileBounds;
      const crs = map.options.crs;
      if (!crs || typeof crs.unproject !== "function") {
        return null;
      }
      const southWest = crs.unproject(L.point(minX, minY));
      const northEast = crs.unproject(L.point(maxX, maxY));
      return L.latLngBounds(southWest, northEast);
    }

    function loadScript(url) {
      return new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = url;
        script.async = true;
        script.onload = () => resolve(url);
        script.onerror = () => reject(new Error(`ËÑöÊú¨Âä†ËΩΩÂ§±Ë¥•: ${url}`));
        document.head.appendChild(script);
      });
    }

    async function loadScriptsSequential(urls) {
      let lastError = null;
      for (const url of urls) {
        try {
          setStatus(`Âä†ËΩΩËÑöÊú¨: ${url}`);
          await loadScript(url);
          return url;
        } catch (error) {
          lastError = error;
        }
      }
      throw lastError || new Error("ËÑöÊú¨Âä†ËΩΩÂ§±Ë¥•");
    }

    function loadLocalTileLayer() {
      if (!map) {
        return;
      }
      const { localTileUrl, tileSize } = GEO_CONFIG;
      if (!localTileUrl) {
        setStatus("Êú¨Âú∞Áì¶Áâá: ÈÖçÁΩÆ‰∏çÂÆåÊï¥");
        return;
      }

      setStatus("Êú¨Âú∞Áì¶Áâá: Âä†ËΩΩ‰∏≠...");
      rasterLayer = L.tileLayer(localTileUrl, {
        tileSize,
        maxZoom: 18,
        tms: false,
      });

      rasterLayer.addTo(map);
      setStatus("Êú¨Âú∞Áì¶Áâá: Â∑≤Âä†ËΩΩ");
    }

    function initMap() {
      map = L.map("map", {
        zoomControl: true,
        attributionControl: true,
      }).setView([39.9042, 116.4074], 15);

      L.tileLayer("https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png", {
        subdomains: ["a", "b", "c"],
        maxZoom: 21,
        attribution:
          '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, HOT',
      }).addTo(map);
    }

    async function loadLeaflet() {
      await loadScriptsSequential([
        "leaflet/leaflet.js",
      ]);
      if (typeof L === "undefined") {
        throw new Error("Leaflet ËÑöÊú¨Êú™Âä†ËΩΩ");
      }
      userIcon = L.icon({
        iconUrl: "https://appassets.androidplatform.net/res/drawable/cursor.png",
        iconSize: [120, 120],
        iconAnchor: [60, 60],
      });
    }

    async function initRasterLayer() {
      try {
        if (GEO_CONFIG.localTileEnabled) {
          loadLocalTileLayer();
          return;
        }
        setStatus("ËÑöÊú¨Âä†ËΩΩÂÆåÊàêÔºåÂáÜÂ§áÂä†ËΩΩÊú¨Âú∞Áì¶Áâá");
        loadLocalTiff();
      } catch (error) {
        console.error(error);
        setStatus(`ËÑöÊú¨Âä†ËΩΩÂ§±Ë¥•: ${error.message || error}`);
      }
    }

    async function init() {
      try {
        await loadLeaflet();
        initMap();
        await initRasterLayer();
        if (tileToggleInput) {
          tileToggleInput.checked = GEO_CONFIG.localTileEnabled;
          tileToggleInput.addEventListener("change", (event) => {
            setLocalTilesVisible(event.target.checked);
          });
        }
      } catch (error) {
        console.error(error);
        setStatus(`Leaflet Âä†ËΩΩÂ§±Ë¥•: ${error.message || error}`);
      }
    }

    init();
</script>
</body>
</html>
